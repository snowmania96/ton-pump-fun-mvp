#include "imports/stdlib.fc";

(slice, cell, cell, cell) load_data() inline {
    slice ds = get_data().begin_parse();
    return (
        ds~load_msg_addr(), ;; admin_address
        ds~load_ref(), ;; content
        ds~load_ref(), ;; jetton_minter_code
        ds~load_ref() ;; deployed_tokens
    );
}

() save_data(slice admin_address, cell content, cell jetton_minter_code, cell deployed_tokens) impure inline {
    set_data(begin_cell()
            .store_slice(admin_address) ;; admin_address
            .store_ref(content) ;; content
            .store_ref(jetton_minter_code) ;;jetton minter code
            .store_ref(deployed_tokens) ;; list of deployed tokens
            .end_cell()
    );
}

() recv_internal(int msg_value, cell in_msg_full, slice in_msg_body) impure {
    if(in_msg_body.slice_empty?()) {
        return ();
    }

    (slice admin_address, cell content, cell jetton_minter_code, cell deployed_tokens) = load_data();

    int op = in_msg_body~load_uint(32);

    if (op == op::init()) {
        admin_address = in_msg_body~load_msg_addr();
        deployed_tokens = begin_cell().end_cell(); ;;Initialize empty list
        save_data(admin_address, content, jetton_minter_code, deployed_tokens);
    } elseif (op == op::deploy_token()) { ;; Deploy
        ;; Deploy Token Contract
        throw_unless(in_msg_body~load_msg_addr() == admin_address);

        ;; Load token metadata
        ;; int name = in_msg_body~load_string();
        ;; int symbol = in_msg_body~load_string();
        ;; int description = in_msg_body~load_string();
        int token_total_supply = in_msg_body~load_coins();

        ;; Create initial data for Jetton Minter Contract
        var minter_data = create_jetton_minter_state_init(token_total_supply, admin_address, content, jetton_minter_code);

        ;; Calculate the address of the new Jetton Minter Contract
        var minter_address = calculate_address(minter_data, jetton_minter_code);

        ;; Deploy the Jetton Minter Contract
        send_message(
            begin_cell()
                .store_uint(0x18, 6) ;; Message mode (0x18 = simple send)
                .store_slice(minter_address) ;; Destination address
                .store_coins(token_total_supply) ;; Initial balance for the new contract
                .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1) ;; Default message headers
                .store_ref(minter_data) ;; Initial data
                .store_ref(jetton_minter_code) ;; Contract code
                .end_cell()
        );

        ;; Store deployed contract address
        deployed_tokens = store_address(minter_address, deployed_tokens);
        save_data(total_supply, admin_address, content, jetton_minter_code, deployed_tokens);
    }
}

;; Helper: Create Jetton Minter Contract initial data
cell create_jetton_minter_state_init(int token_total_supply, slice admin_address, cell content, cell jetton_minter_code) {
  return begin_cell()
          .store_uint(0, 2)
          .store_dict(jetton_minter_code)
          .store_dict(pack_jetton_minter_data(token_total_supply, admin_address, my_address(), jetton_minter_code))
          .store_uint(0, 1)
         .end_cell();
}

cell pack_jetton_minter_data(int balance, slice admin_address, slice sender_address, cell jetton_minter_code) inline {
   return  begin_cell()
            .store_coins(balance)
            .store_slice(admin_address)
            .store_slice(jetton_minter_address)
            .store_ref(jetton_wallet_code)
           .end_cell();
}

slice calculate_jetton_minter_address(cell state_init) inline {
  return begin_cell().store_uint(4, 3)
                     .store_int(workchain(), 8)
                     .store_uint(cell_hash(state_init), 256)
                     .end_cell()
                     .begin_parse();
}


;; Helper: Calculate contract address
slice calculate_address(cell data, cell code) {
    var state_init = begin_cell()
        .store_ref(data)
        .store_ref(code)
        .end_cell();
    return state_init.hash(); ;; Address is the hash of the state_init cell
}

cell store_address(slice address, cell list) {
    return begin_cell()
        .store_ref(list)
        .store_slice(address)
        .end_cell();
}